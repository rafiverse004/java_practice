Time Complexity Cheat Sheet

1. Basic Concepts:
Time Complexity (Big-O): Measures how runtime grows with input size `n`.
Ignore constants → O(2n) → O(n)
Ignore lower-order terms → O(n² + n) → O(n²)
Worst-case is generally considered unless stated.





2. Common Complexities:
| Complexity     | Example                    | Growth Pattern      |
| -------------- | -------------------------- | ------------------- |
|   O(1)         | Access array, assignment   | Constant, no growth |
|   O(log n)     | Binary Search, i*=2 loops  | Logarithmic         |
|   O(n)         | Single loop over n         | Linear              |
|   O(n log n)   | Merge Sort, Heap Sort      | Linearithmic        |
|   O(n²)        | Nested loops, Bubble Sort  | Quadratic           |
|   O(n³)        | Triple nested loops        | Cubic               |
|   O(2ⁿ)        | Fibonacci naive recursion  | Exponential         |
|   O(n!)        | Permutations, Backtracking | Factorial           |





3. Loop Patterns:
| Loop Type         | Example                               | Time Complexity   |
| ----------------- | ------------------------------------- | ----------------- |
| Single loop       |  for(int i=0;i<n;i++)                 | O(n)              |
| Nested loop       |  for (i=0;i<n;i++){ for (j=0;j<n;j++)}| O(n²)             |
| Decreasing loop   |  for(i=n;i>0;i/=2)                    | O(log n)          |
| Nested mixed      |  for(i=0;i<n;i++){ for (j=1;j<n;j*=2)}| O(n log n)        |
| Consecutive loops |  for i...  then  for j...             | Take max, not sum |





4. Recursion Patterns
| Type             | Example                | Recurrence          | Complexity |
| ---------------- | ---------------------- | ------------------- | ---------- |
| Linear           | func(n-1)              | T(n) = T(n-1)+O(1)  | O(n)       |
| Divide & Conquer | func(n/2)              | T(n) = 2T(n/2)+O(n) | O(n log n) |
| Exponential      | func(n-1) called twice | T(n) = 2T(n-1)+O(1) | O(2ⁿ)      |

Quick Tips:
Count number of recursive calls × work per call
Look for tree height in divide & conquer
Recognize common patterns: O(n), O(log n), O(2ⁿ)





5. Special Cases / Tricks
   1. Ignoring constants:
      O(100n) → O(n)
      O(50) → O(1)

   2. Ignoring lower-order terms:
      O(n² + n) → O(n²)
      O(n log n + n) → O(n log n)

   3. Nested loops multiply:
      Outer loop O(n), inner O(n) → O(n²)

   4. Consecutive loops take max:
      for i O(n) then for j O(log n) → O(n)

   5. Worst case dominates:
      If-else branches → pick the slower one

   6. Examples
      Bubble Sort:

for i=0 to n-1
    for j=0 to n-i-1
        swap if needed

Outer loop → n
Inner loop → n
Total → O(n²)






Binary Search:
while(low<=high)
    mid=(low+high)/2


Each step halves the array → O(log n)



Merge Sort:
Split array in half each time, merge in O(n)
T(n) = 2T(n/2) + O(n) → O(n log n)

Naive Fibonacci:
fib(n) = fib(n-1) + fib(n-2)

Recursion tree doubles each time → O(2ⁿ)