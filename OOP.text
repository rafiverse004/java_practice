1. OOP Fundamentals

    What is OOP
    Why OOP exists
    Procedural vs OOP
    Objects vs data structures
    Heap vs stack (basic idea)





2. Class & Object

    Class definition
    Object instantiation (`new`)
    Fields (instance variables)
    Methods
    Object references
    Memory layout (object in heap, reference in stack)





3. Encapsulation (CORE FOUNDATION)

    Access modifiers (`private`, `default`, `protected`, `public`)
    Data hiding
    Getters and setters
    Validation logic
    Invariants (valid object state)
    Why public fields are bad
    Encapsulation vs security





4. Constructors

    Default constructor
    Parameterized constructor
    Constructor overloading
    Constructor chaining
    Object initialization order
    Constructor vs method
    Private constructors (use cases)





5. `this` Keyword

    Referring to current object
    Resolving name conflicts
    Calling another constructor
    Passing current object
    Returning `this`





6. `static` Members

    Static variables
    Static methods
    Static blocks
    Class loading
    Static vs instance context
    Limitations of static
    When static breaks OOP





7. Abstraction

    What abstraction really means
    Abstract methods
    Abstract classes
    Interfaces
    Contract-based design
    Hiding implementation details
    When to abstract
    Over-abstraction problems





8. Interface (Deep)

    Interface definition
    Implementing interfaces
    Multiple inheritance via interfaces
    Marker interfaces
    Default methods (Java 8+)
    Static interface methods
    Functional interfaces (conceptual)





9. Abstract Class (Deep)

    Abstract vs concrete methods
    Fields in abstract classes
    Constructors in abstract classes
    Partial abstraction
    Abstract class vs interface (decision rules)





10. Inheritance (USE CAREFULLY)

    `extends`
    IS-A relationship test
    Method overriding
    Access level rules
    Constructor inheritance rules
    `super` keyword
    Overriding vs hiding
    Inheritance pitfalls
    Fragile base class problem





11. `super` Keyword

    Access parent fields
    Call parent methods
    Call parent constructor
    `super()` rules
    `this()` vs `super()`





12. Polymorphism (REAL OOP POWER)

    Compile-time vs runtime polymorphism
    Method overriding
    Dynamic method dispatch
    Upcasting
    Reference type vs object type
    Polymorphism with interfaces
    Eliminating `if-else`
    Runtime behavior selection





13. Method Overloading

    Method signature
    Parameter rules
    Automatic type promotion
    Ambiguous calls
    Overloading vs overriding
    Why overloading is not real polymorphism





14. Type Casting

    Upcasting (implicit)
    Downcasting (explicit)
    `instanceof`
    ClassCastException
    Safe casting patterns





15. `final` Keyword

    Final variables
    Final methods
    Final classes
    Immutability connection
    Performance myths





16. Object Class (VERY IMPORTANT)

    `toString()`
    `equals()`
    `hashCode()`
    Contract between equals and hashCode
    `getClass()`
    Cloning basics





17. Equality & Identity

    `==` vs `equals()`
    Reference equality
    Logical equality
    Immutable vs mutable equality
    Common mistakes





18. Immutability

    What immutable objects are
    Why immutability matters
    Design rules
    Defensive copying
    Thread-safety benefits
    Examples (`String`)





19. Composition (HAS-A)

    Object composition
    Tight vs loose coupling
    Constructor injection
    Setter injection
    Composition vs inheritance
    Why composition is preferred





20. SOLID Principles

    Single Responsibility Principle
    Open/Closed Principle
    Liskov Substitution Principle
    Interface Segregation Principle
    Dependency Inversion Principle
    Violations and consequences





21. Common OOP Anti-Patterns

    God object
    Anemic model
    Deep inheritance trees
    Overuse of static
    Tight coupling
    Shotgun surgery





22. Basic Design Patterns (OOP Usage)

    Strategy
    Factory
    Template Method
    Singleton (and why itâ€™s dangerous)
    Dependency Injection (concept)





23. Real-World Application Mapping

    Modeling real entities
    Behavior vs data
    Avoiding inheritance abuse
    Designing extensible systems
    Refactoring procedural code into OOP
